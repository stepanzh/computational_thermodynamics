```{eval-rst}
.. meta::
   :description: Упражнения для освоения базового синтаксиса языка Julia.
   :keywords: julia, программирование, упражнения
```

# Задания

## Упражнения

Требования по оформлению

- Одно упражнение -- один файл с именем `ex_номерУпражнения.jl`, например, `ex_1.jl`, `ex_2.jl`;
- Поместите в скрипт с решением пример работы программы с печатью входных данных и результата (достаточно использовать макрос `@show`).
  Исключение -- упражнения с чтением потока ввода;
- Поместите все решения упражнений в zip архив с названием `exercises.zip`.

1\.
Вводится два целых числа через пробел (в стандартный поток ввода).
Вывести через пробел сначала меньшее, затем большее из чисел.

2\.
Кузнечик прыгает либо на одну клетку вперёд, либо на три (например, с 1-ой на 2-ую или на 4-ую).
Напишите функцию, подсчитывающую количество способов добраться из клетки с номером 1 до клетки с номером `n > 1`.

3\.
Напишите функцию, которая принимает на вход массив из чисел и возвращает _новый массив_, состоящий из положительных чисел исходного массива с сохранением порядка.
Пример входных и выходных данных:

```julia
filterpositive([8, 0, -1, 2, -10]) == [8, 2]
```

4\.
Функция принимает на вход массив из целых неотрицательных чисел.
Функция _создаёт массив_ из исходного, в котором сначала отсортированы по возрастанию нечётные числа, а затем, по возрастанию, чётные.
Пример входных и выходных данных:

```julia
sortoddeven([7, 4, 2, 9, 0, 1]) == [1, 7, 9, 0, 2, 4]
```

5\.
Напишите функцию, подсчитывающую векторную проекцию вектора $\mathbf{x}$ на направление $\mathbf{d}$.
Пример входных и выходных данных:

```julia
#          x =     d =
projection([1, 1], [2, 0]) == [1, 0]
```

6\.
Подсчитайте давление $P_r = P / P_c$ газа ван дер Ваальса вдоль изотерм $T_r = T / T_c = 0.85, 1.0, 1.15$.
Уравнение состояния имеет вид $P_r = 8 T_r / (3 V_r - 1) - 3 / V_r^2$, где $V_r = V / V_c$.

- Уравнение состояния должно быть оформлено в виде функции `pressurevdw(Vr, Tr)`;
- При подсчёте изотерм давления используйте объёмы из полуинтервала $V_r \in (1/3, 5]$.

## Создание пакета

Это ознакомительное задание для освоения языка Julia. Вам необходимо разработать пакет (package), содержащий один модуль, несколько структур данных и функций.

Файлы для разработки пакета уже сгенерированы и находятся в репозитории [CTTaskPoints](https://github.com/stepanzh/CTTaskPoints). Вам же необходимо работать в директории `srс/`, дописав модуль Points до конца.

В задание встроена система тестов для самопроверки.

Все инструкции по скачиванию задания и системы самопроверки находятся в репозитории.

### Содержание задания

Необходимо дописать модуль Points, реализовав следующее.

Структура данных `Point`, отвечающая за точку на декартовой плоскости.

- Конструктор: `Point(x, y)`.

Линейные операции с точками:

- Сложение;
- Вычитание;
- Умножение на скаляр;
- Деление на скаляр. Деление на ноль при этом особым образом не обрабатывается;
- Реализация должна расширять стандартные операторы `+`, `-`, `*` и `\`.

У точек должны быть операции скалярного произведения и евклидовой нормы. При этом необходимо перегрузить операции стандартного модуля линейной алгебры: `LinearAlgebra.dot(p, q)` и `LinearAlgebra.norm(p)`.

Написать функцию `center(points)`, находящую "центр масс" точек.

- Аргумент `points`: коллекция точек, например, вектор из точек;
- Возвращаемое значение -- точка `Point`;
- Примеры:
  + `center([Point(0, 0), Point(0, 1)]) == Point(0, 0.5)`;
  + `center([Point(1, 1)]) == Point(1, 1)`;
- Желательно, чтобы аргумент `points` мог быть любой коллекцией, но достаточно сделать реализацию для вектора из точек.

Написать функцию поиска k-ближайших соседей `neighbors(points, origin, k)`, в качестве расстояния используется евклидово расстояние.

- Аргумент `points`: коллекция точек, среди которых ищутся соседи;
- Аргумент `origin`: точка, соседи которой ищутся, может содержаться в `points`;
- Аргумент `k`: целое количество соседей, необходимое найти. В случае поиска нулевого или отрицательного количества соседей считать, что соседей нет;
- Возвращаемое значение: вектор точек `Vector{<:Point}`.

Структура данных `Circle`, отвечающая за круговую область

- Конструктор: `Circle(o, radius)`, где `o <: Point` -- центр круга, а `radius` радиус круга.

Структура данных `Square`, отвечающая за квадратную область со сторонами, параллельными осям координат.

- Конструктор: `Square(o, side)`, где `o <: Point` -- центр квадрата, а `side` длина его стороны.

Операция принадлежности точки области

- Перегружать стандартный оператор `in`;
- Для `Circle` и `Square`;
- Области считать замкнутыми: если точка попадает на границу области, считать, что она ей принадлежит;
- Примеры:
  +  `Point(0, 0) in Circle(Point(0, 0.5), 1)  # true`;
  + `Point(0, 0) in Circle(Point(0, 0.5), 0.5)  # true`.

Написать метод `center(points, area)` для функции `center`, находящий "центр масс" точек, принадлежащих области

- Аргумент `points`: коллекция точек. Гарантируется, что хотя бы одна из точек принадлежит области `area`;
- Аргумент `area`: `Circle` или `Square` -- область, 
- Возвращаемое значение: точка `Point`;
- Примеры:
  + `center([Point(0, 0), Point(1, 0)], Circle(Point(0.75, 0), 0.25)) == Point(1, 0)`;
  + `center([Point(0, 0), Point(1, 0)], Circle(Point(0.75, 0), 0.76)) == Point{Float64}(0.5, 0.0)`;
- Желательно, чтобы аргумент `points` мог быть любой коллекцией, но достаточно сделать реализацию для вектора из точек.
  
Бонусы:

- Стабильность по типам функции `neighbors`;
- Стабильность по типам вызова `center(points, ::Circle)`;
- Стабильность по типам вызова `center(points, ::Square)`.
