```{eval-rst}
.. meta::
   :description: Julia. Числовые типы, переменные, математические операции и логические типы.
   :keywords: julia, программирование, основы, переменные
```

# Числа, переменные, Bool

Данный раздел является кратким обзором следующих разделов манула

- Variables **[[url]](https://docs.julialang.org/en/v1/manual/variables/)**;
- Integers and Floating-Point Numbers **[[url]](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/)**;
- Mathematical Operations and Elementary Functions **[[url]](https://docs.julialang.org/en/v1/manual/mathematical-operations/)**;
- Complex and Rational Numbers **[[url]](https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/)**.

## Числа и переменные

В Julia богатая система встроенных числовых типов, узнать тип переменной или литерала можно с помощью функции `typeof(x)`.

```julia-repl
julia> typeof(5)
Int64

julia> typeof(5.0)
Float64

julia> typeof(5im)
Complex{Int64}

julia> typeof(2.3 + 5.0im)
ComplexF64 (alias for Complex{Float64})

julia> typeof(2//3)
Rational{Int64}

julia> typeof(1//3 + 2//3im)
Complex{Rational{Int64}}

```

Синтаксис присвоения значения переменной стандартный, также поддерживается параллельное присваивание и каскадное.

```julia-repl
julia> x = 5
5

julia> x, y = 1, 2
(1, 2)

julia> x
1

julia> y
2

julia> x = y = 1
1

julia> x, y
(1, 1)

julia> (x = (y = 2) + (z = 3))
5

julia> x, y, z
(5, 2, 3)
```

В исполнительном режиме REPL печатает возращаемое значение, его можно опустить с помощью `;` в конце выражения.

```julia-repl
julia> x = 10;

julia> x
10
```

```{margin}
Список поддерживаемых для набора в REPL Unicode символов **[[url]](https://docs.julialang.org/en/v1/manual/unicode-input/)**.
```
В имена переменных могут входить любые [Unicode](https://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4) символы.
REPL позволяет набирать часто употребляемые с помощью LaTeX-подобного синтаксиса и {kbd}`Tab ⇥`, например, так выглядит набор символов `α₁`:

```julia-repl
julia> \alpha  # потом нажмите `<Tab>`, и ввод сменится на α
       α
       α\_1  # `<Tab>`
       α₁
```

```{list-table} Некоторые операторы и функции.
:header-rows: 1

* - Описание
  - Синтаксис
* - Бинарные операторы `+`, `-`, `*`, `/`
  - `x + y`, `x - y`, `x * y`, `x / y`
* - Функции `+`, `-`, `*`, `/`
  - `+(x, y,..)`, `-(x, y)`, `*(x, y,..)`, `/(x, y)`
* - Унарный минус
  - `-x` или `-(x)`
* - Частное от деления целых
  - `x ÷ y` или `÷(x, y)` или `div(x, y)`
* - Остаток от деления целых
  - `x % y` или `%(x, y)` или `rem(x, y)`
* - Возведение в степень $x^y$
  - `x ^ y` или `^(x, y)`
* - Логарифмы $\ln(x)$, $\log_2(x)$, $\log_{10}(x)$
  - `log(x)`, `log2(x)`, `log10(x)`
* - Тригонометрия $\sin(x)$, $\cos(x)$
  - `sin(x)`, `cos(x)`
* - Квадратный корень $\sqrt{x}$
  - `sqrt(x)`
```

Математические константы

```julia-repl
julia> π                    # \pi<Tab>
π = 3.1415926535897...

julia> ℯ                    # \euler<Tab>
ℯ = 2.7182818284590...

julia> typeof(ℯ)
Irrational{:ℯ}
```

При применении операций к разным типам аргументов тип результата интуитивен: число из типа, соответствующего, математически "меньшему" множеству конвертируется в тип математически "большего" множества. Затем операция выполняется для одинаковых типов. Система типов в Julia это её позвоночник, см. раздел {ref}`type_system`.

Редко требуется аргумент подать в явном типе, например,

```julia-repl
julia> sqrt(-1.0)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
...

julia> sqrt(-1.0 + 0im)
0.0 + 1.0im
```

```{admonition} Почему?
:class: dropdown
Во-первых, функция корня в математике определяется на разных множествах.

Во-вторых, так удаётся сохранять *стабильность типов*: т.е. когда по типам аргументов функции можно определить тип возвращаемого значения. Если бы функция корня, извлекая из `Float64`, возвращала иногда `Float64`, а иногда `Complex{Float64}`, то предсказать тип возвращаемого значения было бы невозможно. Предсказание типов позволяет *компилировать* функции и методы, не уступающие по скорости аналогам кода на статически типизируемых языках, например, `C/C++`.
```

## Логические типы и сравнение величин

В Julia один логический тип `Bool`, имеющий два значения: `true` и `false`.
Операторы сравнения как правило возвращают тип `Bool` и используются в логических конструкциях.

```{list-table} Некоторые логические операторы и операторы сравнения (функциональные форма не приведена).
:header-rows: 1

* - Описание
  - Синтаксис
* - Логическое отрицание
  - `!a`
* - Логическое И (short-circuit)
  - `a && b`
* - Логическое ИЛИ (short-circuit)
  - `a || b`
* - Равенство по значению
  - `x == y`, `isequal(x, y)` (не взаимозаменяемы)
* - Identity
  - `x === y`, `x ≡ y`
* - Неточное равенство по значению
  - `x ≈ y`, `isapprox(x, y[; kwargs...])`
* - Меньше, чем
  - `x < y` и `x <= y`, `x ≤ y`
* - Больше, чем
  - `x > y` и `x >= y`, `x ≥ y` 
```

Кроме того, существует тип `Missing` с единственным значением `missing`.
Он используется с операторами `&` и `|`, реализующую троичную логику на `true`, `false` и `missing`.
