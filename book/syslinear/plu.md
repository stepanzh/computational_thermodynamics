---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.16.0
kernelspec:
  display_name: Julia 1.9.4
  language: julia
  name: julia-1.9
---

```{code-cell}
:tags: [remove-cell]

include("../src.jl")
```

# PLU-разложение

Разложение, представленное в предыдущем разделе, существует не всегда.

```{proof:demo}
```
```{raw} html
<div class="demo">
```

Применим разложение к следующей матрице.

```{code-cell}
A = [
     1  2  -1  9;
     1  2   1  3;
     5  1   8  7;
    -8  6   5  1;
]
L, U = lufact(A)
L
```

```{code-cell}
U
```

Матрицы разложения имеют `NaN` и `Inf` значения, возникшие в результате деления на ноль. При этом сама матрица обратимая.

```{code-cell}
@show det(A);
```

На первом шаге разложения всё в порядке

```{code-cell}
L = diagm(0 => ones(4))
U = zeros(4, 4)
A₁ = float(copy(A))
U[1, :] .= A₁[1, :]
L[:, 1] .= A₁[:, 1] ./ U[1, 1]
L
```

```{code-cell}
A₂ = A₁ - L[:, 1] * U[1, :]'
```

Из вида матрицы `A₂` понятно, что на втором шаге возникнет деление на ноль. А именно, при присваивании матрице `U` новой строки всё нормально, первое деление на ноль возникает при подсчёте столбца матрицы `L`, поскольку `U[2, 2] == A₂[2, 2]`

```{code-cell}
U[2, :] .= A₂[2, :]
L[:, 2] .= A₂[:, 2] ./ U[2, 2];
L
```

Полученные `NaN` и `Inf` значения распроcтранятся в результате операции

```{code-cell}
A₃ = A₂ - L[:, 2] * U[2, :]'
```

```{raw} html
</div>
```

Чтобы подобной ситуации для обратимых матриц не возникало, достаточно на итерации выбирать главный элемент.

## Выбор главного элемента

Гланым элементом (англ., *pivot*) называют диагональный элемент матрицы `U[k, k]`, который возникает в строке функции {numref}`Функция {number} <function-lufact>`

```julia
for k in 1:n-1
    U[k, :] .= Aₖ[k, :]
    L[:, k] .= Aₖ[:, k] ./ U[k, k]
    Aₖ .-= L[:, k] * U[k, :]'
end
``` 

Чтобы избежать делений на ноль, необходимо выбрать в качестве *главного элемента* ненулевой $p$-ый элемент $k$-ого столбца матрицы `Aₖ`. И затем уже работать со строкой `Aₖ[p, :]` в теле цикла, которую называют *главной строкой*.

Выбрать главный элемент можно разными способами, однако, численная стабильность разложения достигается при выборе элемента с максимальным абсолютным значением.

```{proof:demo}
```
```{raw} html
<div class="demo">
```

Рассмотрим ту же матрицу, что и в начале раздела.

```{code-cell}
A = [
     1  2  -1  9;
     1  2   1  3;
     5  1   8  7;
    -8  6   5  1;
]
L = diagm(0 => ones(4))
U = zeros(4, 4)
A₁ = float(copy(A));
```

Но на этот раз будем производить выбор главного элемента.

```{code-cell}
p = argmax(abs.(A₁[:, 1]))
@show p
@show A₁[p, 1];
```

Функция `argmax` возвращает индекс наибольшего элемента массива. В качестве массива используется столбец из абсолютных значений столбца матрицы `A₁[:, 1]`.

Проведём обновление матриц разложения и убедимся, что на этот раз `L` не содержит неопределённых float-значений.

```{code-cell}
U[1, :] .= A₁[p, :]
L[:, 1] .= A₁[:, 1] ./ U[1, 1];
L
```

Завершим шаг

```{code-cell}
A₂ = A₁ - L[:, 1] * U[1, :]'
```

Поскольку главным элементом был четвёртый, то и `A₂` имеет нулевую четвёртую строку.

Продолжим шаги дальше

```{code-cell}
@show p = argmax(abs.(A₂[:, 2]))
U[2, :] .= A₂[p, :]
L[:, 2] .= A₂[:, 2] ./ U[2, 2]
A₃ = A₂ - L[:, 2] * U[2, :]'

@show p = argmax(abs.(A₃[:, 3]))
U[3, :] .= A₃[p, :]
L[:, 3] .= A₃[:, 3] ./ U[3, 3]
A₄ = A₃ - L[:, 3] * U[3, :]'

@show p = argmax(abs.(A₄[:, 4]))
U[4, :] .= A₄[p, :]
L[:, 4] .= A₄[:, 4] ./ U[4, 4];
```

Мы действительно получили разложение $\mathbf{A}=\mathbf{LU}$

```{code-cell}
A₁ - L*U
```

При этом матрица $\mathbf{U}$ имеет верхнетреугольную структуру

```{code-cell}
U
```

А матрица $\mathbf{L}$ теперь не нижнетреугольная.

```{code-cell}
L
```

Чтобы восстановить структуру матрицы $\mathbf{L}$, достаточно переставить в ней строки согласно последовательности выбора главных элементов. В нашем случае это были $4$, $3$, $1$ и $2$. В Julia это осуществляется с помощью следующего синтаксиса

```{code-cell}
L = L[[4, 3, 1, 2], :]
```

*Voilà!*

```{raw} html
</div>
```

```{proof:proposition}
LU-разложение с выбором главной строки выполнимо, если производится над обратимой матрицей {cite}`fnc2017`.
```

Несмотря на это утверждение, существуют примеры обратимых матриц, для которых *численный алгоритм* разложения всё-таки не работает, однако на практике такие матрицы встречаются редко.

## PLU-разложение

Теперь есть всё, чтобы построить LU-разложение с выбором главной строки. Такое разложение называют PLU-разложением (англ., row-pivoting LU factorization).

```{index} разложение; PLU
```
```{proof:definition} PLU-разложение
Пусть дана матрица $\mathbf{A}$ размера $n\times n$. PLU-разложением называется тройка из

- нижнетреугольной матрицы $\mathbf{L}$;
- верхнетреугольной матрицы $\mathbf{U}$;
- и перестановки $i_1, i_2, \ldots, i_n$ индексов $1, \ldots, n$.

Эта тройка такова, что

$$
\hat{\mathbf{A}} = \mathbf{LU},
$$

где строки $1, \ldots, n$ матрицы $\hat{\mathbf{A}}$ это строки $i_1, i_2, \ldots, i_n$ исходной матрицы $\mathbf{A}$.
```

Итак, для реализации теперь необходимо возвращать не только матрицы разложения, но и вектор-перестановку.

```{proof:function} plufact

**LU-разложение с выбором главной строки**

:::julia
"PLU-разложение матрицы `A`. Возвращает `L`, `U` и вектор-перестановку."
function plufact(A::AbstractMatrix)
    n = size(A, 1)
    p = zeros(Int, n)
    
    U = float(similar(A))
    L = similar(U)
    Aₖ = float(copy(A))
    
    for k in 1:n-1
        p[k] = argmax(abs.(Aₖ[:, k]))
        U[k, :] .= Aₖ[p[k], :]
        L[:, k] .= Aₖ[:, k] ./ U[k, k]
        Aₖ .-= L[:, k] * U[k, :]'
    end
    
    p[n] = argmax(abs.(Aₖ[:, n]))
    U[n, n] = Aₖ[p[n], n]
    L[:, n] = Aₖ[:, n] / U[n, n]
    
    return LowerTriangular(L[p, :]), UpperTriangular(U), p
end
:::
```

```{proof:demo} Пример решения системы
```
```{raw} html
<div class="demo">
```

Рассмотрим решение системы

```{code-cell}
A = [5  1  0  9; 4  2 -1  4; 8 -1  4  1; 5  7  4  6]
b = [1, 2, 7, 3];
```

Как и в случае LU, cначала выполним разложение

```{code-cell}
L, U, p = plufact(A);
p
```

Однако, для решения системы нужно сначала сделать перестановку в векторе правой части $\mathbf{b}$

```{code-cell}
z = forwardsub(L, b[p])
x = backwardsub(U, z)
```

Невязка при этом составила

```{code-cell}
b - A*x
```

```{raw} html
</div>
```

PLU-разложение является центральным алгоритмом для решения систем линейных уравнений общего вида. Его вычислительная сложность (число операций с плавающей точкой: флопс, flops) составляет $\propto \frac{2}{3} n^3$, где $n$ -- размер матрицы системы.

В дальнейшем, упоминая LU-разложение, мы для краткости будем подразумевать PLU-разложение.

## PLU в Julia

В Julia PLU разложение называется просто LU разложением и доступно в модуле `LinearAlgebra`.

- Функция `lu(A)` возвращает объект разложения `F`, содержащий
    + множители `F.L` и `F.U`
    + матрицу перестановок `F.P`
    + вектор перестановок `F.p`
- Для решения системы уравнений можно пользоваться самим объектом разложения
- Решение системы можно выполнять
    + оператором `F \ b`, тогда решение будет аллоцироваться
    + функцией `ldiv!(x, F, b)`, тогда решение не будет аллоцироваться и запишется в `x`

```julia-repl
julia> A = [5  1  0  9; 4  2 -1  4; 8 -1  4  1; 5  7  4  6];
julia> b = [1, 2, 7, 3];
julia> F = lu(A);

julia> F \ b - A \ b
4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0

julia> norm(F.L * F.U - A[F.p, :])
5.570606194861277e-16

julia> F.p
4-element Vector{Int64}:
 3
 4
 2
 1

julia> ldiv!(x, F, b);
julia> norm(x - F \ b)
0.0
```

```{margin}
Технические детали здесь опускаются, диспатч оператора `\` [немного сложнее](https://github.com/JuliaLang/julia/blob/eea2ca79ea00060080de64c1449454bb86bc10cf/stdlib/LinearAlgebra/src/generic.jl#L1065-L1113).
```
В чём разница между `A \ b` и `F \ b`? У оператора `\` есть несколько методов. Наиболее общий из них принимает на вход `AbstractMatrix` и вектор `AsbtractVector`. Этот метод проверяет, квадратная ли система, и является ли она треугольной. Если условия не выполнены, то применяется LU разложение, и вызывается второй метод -- `F \ b`. Таким образом, в первом случае производятся проверки и LU разложение, а во втором нет -- разложение уже хранится в `F` и достаточно применить прямую/обратную подстановки.
