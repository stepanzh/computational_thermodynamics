---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.16.0
kernelspec:
  display_name: Julia 1.9.4
  language: julia
  name: julia-1.9
---

```{eval-rst}
.. meta::
   :description: В данном разделе мы определяем понятие графа вычислений, которое понадобится для классификации видов автоматического дифференцирования.
   :keywords: граф вычислений, автоматическое дифференцирование, производная, вычислительная математика, вычматы
```

(sec:autodiff:compgraph)=
# Граф вычислений

```{index} граф; вычислений
```
Для общего представления автоматического дифференцирования нам понадобится **граф вычислений**.
Это ориентированный граф для представления последовательности вычислений, скажем, функции $f$.

Обычно вершинами графа являются операции или их аргументы, а рёбра связывают операции с аргументами.
Мы же воспользуемся упрощённым описанием, которого хватит для наших целей.
Так, в вершины графа мы будем помещать значения, возникающие в ходе вычислений (включая аргументы $f$ и итоговое значение), а рёбра (дуги) графа будут соединять аргументы операции с её результатом.

Рассмотрим несколько примеров.

```{figure} static/graph-unary.svg
---
name: fig:autodiff:graph-unary
---

Граф вычислений $f(x) = \sin x$.
```

На {numref}`Рисунке %s <fig:autodiff:graph-unary>` показан граф вычисления унарной функции (функции одного аргумента).
В этом случае $x_1 \equiv x$, а $x_2 \equiv f(x)$.


```{figure} static/graph-binary.svg
---
name: fig:autodiff:graph-binary
---

Граф вычислений для операции суммы.
```

На {numref}`Рисунке %s <fig:autodiff:graph-binary>` показан граф вычисления суммы $x_1 + x_2$ с хранением результата в $x_3$.
С формальной точки зрения, операцию сложения можно представить в виде функции двух аргументов (бинарной функции).
В таком случае стоки вершины $x_3$ соединяют её с аргументами операции, а саму операцию мы будем подписывать рядом с вершиной-результатом.


```{figure} static/graph-example.svg
---
name: fig:autodiff:graph-example
---

Граф вычислений функции $f(x_1, x_2, x_3) = (x_1 x_2 + \sin{x_3})/x_3$.
```

На {numref}`Рисунке %s <fig:autodiff:graph-example>` показан граф вычисления функции трёх переменных

```{math}
f(x_1, x_2, x_3) = \frac{x_1 x_2 + \sin{x_3}}{x_3},
```

которую мы будем в качестве примера в последующих разделах.
Значения $x_1$, $x_2$ и $x_3$ являются аргументами функции, а $x_7$ --- значением функции в точке $[x_1, x_2, x_3]^\top$.
Промежуточные значения функции приведены ниже.

```{code-cell}
function f(x₁, x₂, x₃)
    @show x₁
    @show x₂
    @show x₃
    @show x₄ = x₁ * x₂
    @show x₅ = sin(x₃)
    @show x₆ = x₄ + x₅
    @show x₇ = x₆ / x₃
    return x₇
end

f(1, 2, 3)
```

Те же промежуточные значения $x_4$, $x_5$, $x_6$, $x_7$ создаёт компилятор языка.
Они обозначаются как `%номер` в Julia.

```{code-cell}
f2(x₁, x₂, x₃) = (x₁ * x₂ + sin(x₃)) / x₃
@code_lowered f2(1, 2, 3)
```

В нашем случае `x₄ = %1`, `x₅ = %2`, `x₆ = %3` и `x₇ = %4`.

Для создания машинного (или промежуточного представления) кода из исходного компилятор строит синтаксическое дерево.
Если не вдаваться в технические детали, синтаксическое дерево напоминает граф вычислений, который мы описывали выше.
Однако, в синтаксическом дереве содержатся не только "привычные" математические операции, но и операторы языка, например, операторы ветвления, циклов или вызова функций.
Кроме того, на разных платформах (железе или операционной системе) машинный код может быть разным, но синтаксические деревья (и исходный код) могут совпадать ввиду более высокого уровня абстракции вычисления.

В следующих разделах мы воспользуемся графом вычисления, показанном на {numref}`Рисунке %s <fig:autodiff:graph-example>`, для классификации методов автоматического дифференцирования.
